# Load тестване

Това упражнение ще разгледаме какво представляват **Load** тестове, защо се използват и как ние можем да пише Load тестове за нашето приложение.

## Какво са Load тестове?

Load тестовете са вид тестове за производителност, които измерват как системата се държи под натоварване, обикновено чрез симулиране на множество потребители или транзакции. Използват се, за да се идентифицират bottlenecks, да се определи максималният капацитет на системата и да се гарантира, че тя може да обработва очакваното натоварване без проблеми.

## Примерно приложение

Имаме просто уеб приложение, което искаме притежава следните endpoint-ове:

```js
app.get("/", (req, res) => {
  res.sendFile(path.join(__dirname, "/index.html"));
});
```

, който служи за връщане `index.html`.

```js
app.post("/login", (req, res) => {
  res.send(req.body);
});
```

, който приема POST заявка и връща обратно тялото на заявката (`req.body`) като отговор.

```js
app.post("/capitalize", (req, res) => {
  ans = { ...req.body };
  ans.name = ans.name.toUpperCase();
  ans.email = ans.email.toUpperCase();

  res.send(ans);
});
```

, който приема POST заявка и очаква тялото на заявката (`req.body`) да съдържа обект с полета `name` и `email`. Endpoint-а преобразува стойностите на тези полета в главни букви (чрез `toUpperCase()`) и връща модифицирания обект като отговор.

## k6

k6 е мощен и модерен инструмент за load тестване, разработен от компанията Grafana Labs. Той е написан на Go и използва JavaScript за дефиниране на тестовите сценарии. k6 е проектиран да бъде лесен за използване, ефективен и да предоставя подробни резултати за производителността на вашите системи.

### Създаване на тестов сценарий

Тестовите сценарий се пишат като `JavaScript` . Ето един прост пример:

```js
import http from 'k6/http';
import { check, sleep } from 'k6';

export default function () {
  let res = http.get('https://test.k6.io');
  check(res, {
    'status is 200': (r) => r.status === 200,
  });
  sleep(1);
}
```

- Във функцията дефинираме какво действие ще се изпълнява. В този пример, k6 изпраща HTTP GET заявка към `https://test.k6.io` и проверява дали статус кодът на отговора е 200.

Допълнително за всеки тест можем да добавим опции:

```js
export let options = {
  vus: 10,
  duration: '30s',
};
```

 - Полето `vus` определя колко виртуални потребители ще изпълняват тестовете едновременно, а `duration` - за колко секунди ще се изпълнява теста.

Общо теста ще изглежда по следният начин:

```js
import http from 'k6/http';
import { check, sleep } from 'k6';

export let options = {
  vus: 10,
  duration: '30s',
};

export default function () {
  let res = http.get('https://test.k6.io');
  check(res, {
    'status is 200': (r) => r.status === 200,
  });
  sleep(1);
}
```

### Изпълнение на теста

За изпълним дадем тест, използваме командата:

```bash
k6 run script.js
```

- k6 ще изпълни теста и ще предостави подробен отчет за резултатите.

### Анализ на резултатите

След като тестът приключи, k6 ще предостави подробен отчет, включващ метрики като:
- Брой заявки
- Средно време за отговор
- Процент на успешни заявки
- Други метрики, свързани с производителността

### Изпращане на данни

- Ако искаме да тестваме натоварването при изпращане на данни ( например при POST заявки ), можем по следният начин:

```js
export default function () {
    const url = 'http://localhost:8080/login';
    const payload = JSON.stringify({
        email: 'aaa',
        password: 'bbb',
    });

    const params = {
        headers: {
            'Content-Type': 'application/json',
        },
    };

    http.post(url, payload, params);

}
```

- Тук в променливата `payload` ще дефинираме данните, които ще изпратим, а в `params` какви параметри ще подадем на заявката. Накрая чрез `http.post` изпълняваме POST заявка към съответният адрес.

## Сценарии

Чрез сценариите ни можем да имаме няколко вида натоварвания към дадена функция, които да се изпълняват паралелно. Сценарии се дефинират по следният начин:

```js
export const options = {
    scenarios: {
        shared_iter_scenario: {
            executor: "shared-iterations",
            vus: 10,
            iterations: 100,
            startTime: "0s",
        },
        per_vu_scenario: {
            executor: "per-vu-iterations",
            vus: 10,
            iterations: 10,
            startTime: "10s",
        },
    },
};
```

Тук имаме две сценария - `shared_iter_scenario` и `per_vu_scenario`.

- При `shared_iter_scenario`:
    - `executor: "shared-iterations"` споделя итерациите между всички виртуални потребители (VUs). Това означава, че общият брой итерации (в този случай 100) ще бъде разпределен между всички VUs (в този случай 10). Например, ако имате 10 VUs и 100 итерации, всеки VU ще изпълни приблизително 10 итерации.
    - `vus: 10` дефинира броя на виртуалните потребители (VUs), които ще участват в този сценарий. В този случай, 10 VUs ще бъдат използвани.
    - `iterations: 100` дефинира общият брой итерации, които трябва да бъдат изпълнени от всички VUs заедно. В този случай, общо 100 итерации ще бъдат изпълнени.
    - `startTime: "0s"` указва кога този сценарий ще започне. В този случай, той започва веднага след стартирането на теста (`0s`).
- При `per_vu_scenario`:
    -  `executor: "per-vu-iterations"` задава, че всеки виртуален потребител (VU) ще изпълни определен брой итерации независимо от другите VUs. В този случай, всеки от 10-те VUs ще изпълни по 10 итерации, което означава, че общият брой итерации ще бъде `10 VUs * 10 итерации = 100 итерации`.
    - `vus: 10` дефинира броят на виртуалните потребители (VUs), които ще участват в този сценарий. В този случай, 10 VUs ще бъдат използвани.
    - `iterations: 10` дефинира броят итерации, които всеки VU трябва да изпълни. В този случай, всеки VU ще изпълни 10 итерации.
    - `startTime: "10s"` указва кога този сценарий ще започне. В този случай, той започва 10 секунди след стартирането на теста (`10s`).

## Задание

1. Създайте ваш fork на [хранилището на приложението](https://github.com/yordan-vladov/load_testing_intro) и го клонирайте.
2. Свалете и инсталирайте "к6" и проверете дали работи. [Инструкции](https://grafana.com/docs/k6/latest/set-up/install-k6/).
3. Пуснете приложението да работи.
4. От друг терминал (или от същият) изпълнете тестовете от директорията `load-testing` чрез командата `k6 run`.
5. Създайте още един файл в папката `load-testing`, в който да напишете load тест за endpoint-a `/capitalize`. Дефинирайте в опциите на теста два сценария с подходящ брой виртуални потребители и подходяща дължина. Изпълнете теста.
6. Качете вашият fork с добавеният тест, както и екранни снимки на направените тестове.
